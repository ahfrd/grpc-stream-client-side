// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "datastream.proto" (package "market_trend", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * @generated from protobuf message market_trend.FilterRequest
 */
export interface FilterRequest {
    /**
     * @generated from protobuf field: string sort = 1
     */
    sort: string;
    /**
     * @generated from protobuf field: string filter = 2
     */
    filter: string;
}
/**
 * @generated from protobuf message market_trend.DataStreamResponse
 */
export interface DataStreamResponse {
    /**
     * @generated from protobuf field: int32 code = 1
     */
    code: number;
    /**
     * @generated from protobuf field: repeated market_trend.EStockInfo data = 2
     */
    data: EStockInfo[];
    /**
     * @generated from protobuf field: string message = 3
     */
    message: string;
}
/**
 * @generated from protobuf message market_trend.EStreamStock
 */
export interface EStreamStock {
    /**
     * @generated from protobuf field: string stock_code = 1
     */
    stockCode: string;
    /**
     * @generated from protobuf field: double open = 2
     */
    open: number;
    /**
     * @generated from protobuf field: double high = 3
     */
    high: number;
    /**
     * @generated from protobuf field: double low = 4
     */
    low: number;
    /**
     * @generated from protobuf field: double close = 5
     */
    close: number;
    /**
     * @generated from protobuf field: double change = 6
     */
    change: number;
    /**
     * @generated from protobuf field: double changePercent = 7
     */
    changePercent: number;
    /**
     * @generated from protobuf field: double volume = 8
     */
    volume: number;
    /**
     * @generated from protobuf field: double value = 9
     */
    value: number;
    /**
     * @generated from protobuf field: double previousClose = 10
     */
    previousClose: number;
    /**
     * @generated from protobuf field: double avg = 11
     */
    avg: number;
    /**
     * @generated from protobuf field: int64 lastUpdated = 12
     */
    lastUpdated: bigint;
    /**
     * @generated from protobuf field: double tradeVolume = 13
     */
    tradeVolume: number;
    /**
     * @generated from protobuf field: double araValue = 14
     */
    araValue: number;
    /**
     * @generated from protobuf field: double arbValue = 15
     */
    arbValue: number;
    /**
     * @generated from protobuf field: double bestBid = 16
     */
    bestBid: number;
    /**
     * @generated from protobuf field: double bestOffer = 17
     */
    bestOffer: number;
    /**
     * @generated from protobuf field: double totalFreq = 18
     */
    totalFreq: number;
    /**
     * @generated from protobuf field: market_trend.EForeign foreign = 19
     */
    foreign?: EForeign;
    /**
     * @generated from protobuf field: double error = 20
     */
    error: number;
    /**
     * @generated from protobuf field: string name = 21
     */
    name: string;
}
/**
 * @generated from protobuf message market_trend.EForeign
 */
export interface EForeign {
    /**
     * @generated from protobuf field: double buy = 1
     */
    buy: number;
    /**
     * @generated from protobuf field: double sell = 2
     */
    sell: number;
}
/**
 * @generated from protobuf message market_trend.TR0002
 */
export interface TR0002 {
    /**
     * @generated from protobuf field: int64 tradeDate = 1
     */
    tradeDate: bigint;
    /**
     * @generated from protobuf field: int64 tradeTime = 2
     */
    tradeTime: bigint;
    /**
     * @generated from protobuf field: int64 tradeNo = 3
     */
    tradeNo: bigint;
    /**
     * @generated from protobuf field: string tradeType = 4
     */
    tradeType: string;
    /**
     * @generated from protobuf field: string securityCode = 5
     */
    securityCode: string;
    /**
     * @generated from protobuf field: string boardCode = 6
     */
    boardCode: string;
    /**
     * @generated from protobuf field: double price = 7
     */
    price: number;
    /**
     * @generated from protobuf field: int64 volume = 8
     */
    volume: bigint;
    /**
     * @generated from protobuf field: string buyerCode = 9
     */
    buyerCode: string;
    /**
     * @generated from protobuf field: string buyerType = 10
     */
    buyerType: string;
    /**
     * @generated from protobuf field: string sellerCode = 11
     */
    sellerCode: string;
    /**
     * @generated from protobuf field: string sellerType = 12
     */
    sellerType: string;
    /**
     * @generated from protobuf field: double bestBid = 13
     */
    bestBid: number;
    /**
     * @generated from protobuf field: int64 bestBidVolume = 14
     */
    bestBidVolume: bigint;
    /**
     * @generated from protobuf field: double bestOffer = 15
     */
    bestOffer: number;
    /**
     * @generated from protobuf field: int64 bestOfferVolume = 16
     */
    bestOfferVolume: bigint;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp tradeTimestamp = 17
     */
    tradeTimestamp?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp updatedDate = 18
     */
    updatedDate?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timeStampStream = 19
     */
    timeStampStream?: Timestamp;
    /**
     * @generated from protobuf field: double fluctAmount = 20
     */
    fluctAmount: number;
    /**
     * @generated from protobuf field: double open = 21
     */
    open: number;
    /**
     * @generated from protobuf field: double high = 22
     */
    high: number;
    /**
     * @generated from protobuf field: double low = 23
     */
    low: number;
    /**
     * @generated from protobuf field: int32 freq = 24
     */
    freq: number;
    /**
     * @generated from protobuf field: int32 totalVol = 25
     */
    totalVol: number;
    /**
     * @generated from protobuf field: int64 totalAmount = 26
     */
    totalAmount: bigint;
}
/**
 * @generated from protobuf message market_trend.EStockInfo
 */
export interface EStockInfo {
    /**
     * @generated from protobuf field: double percentChange = 1
     */
    percentChange: number;
    /**
     * @generated from protobuf field: string code = 2
     */
    code: string;
    /**
     * @generated from protobuf field: string notation = 3
     */
    notation: string;
    /**
     * @generated from protobuf field: double price = 4
     */
    price: number;
    /**
     * @generated from protobuf field: double change = 5
     */
    change: number;
    /**
     * @generated from protobuf field: double totalFreq = 6
     */
    totalFreq: number;
    /**
     * @generated from protobuf field: double totalVolume = 7
     */
    totalVolume: number;
    /**
     * @generated from protobuf field: double volume = 8
     */
    volume: number;
    /**
     * @generated from protobuf field: double value = 9
     */
    value: number;
    /**
     * @generated from protobuf field: string name = 10
     */
    name: string;
    /**
     * @generated from protobuf field: int64 lastUpdated = 11
     */
    lastUpdated: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class FilterRequest$Type extends MessageType<FilterRequest> {
    constructor() {
        super("market_trend.FilterRequest", [
            { no: 1, name: "sort", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "filter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FilterRequest>): FilterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sort = "";
        message.filter = "";
        if (value !== undefined)
            reflectionMergePartial<FilterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilterRequest): FilterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sort */ 1:
                    message.sort = reader.string();
                    break;
                case /* string filter */ 2:
                    message.filter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sort = 1; */
        if (message.sort !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sort);
        /* string filter = 2; */
        if (message.filter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.filter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message market_trend.FilterRequest
 */
export const FilterRequest = new FilterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataStreamResponse$Type extends MessageType<DataStreamResponse> {
    constructor() {
        super("market_trend.DataStreamResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EStockInfo },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DataStreamResponse>): DataStreamResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.data = [];
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<DataStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataStreamResponse): DataStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                case /* repeated market_trend.EStockInfo data */ 2:
                    message.data.push(EStockInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* repeated market_trend.EStockInfo data = 2; */
        for (let i = 0; i < message.data.length; i++)
            EStockInfo.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message market_trend.DataStreamResponse
 */
export const DataStreamResponse = new DataStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EStreamStock$Type extends MessageType<EStreamStock> {
    constructor() {
        super("market_trend.EStreamStock", [
            { no: 1, name: "stock_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "open", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "high", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "low", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "close", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "change", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "changePercent", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "previousClose", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 11, name: "avg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "lastUpdated", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "tradeVolume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 14, name: "araValue", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 15, name: "arbValue", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 16, name: "bestBid", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 17, name: "bestOffer", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 18, name: "totalFreq", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 19, name: "foreign", kind: "message", T: () => EForeign },
            { no: 20, name: "error", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 21, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EStreamStock>): EStreamStock {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stockCode = "";
        message.open = 0;
        message.high = 0;
        message.low = 0;
        message.close = 0;
        message.change = 0;
        message.changePercent = 0;
        message.volume = 0;
        message.value = 0;
        message.previousClose = 0;
        message.avg = 0;
        message.lastUpdated = 0n;
        message.tradeVolume = 0;
        message.araValue = 0;
        message.arbValue = 0;
        message.bestBid = 0;
        message.bestOffer = 0;
        message.totalFreq = 0;
        message.error = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<EStreamStock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EStreamStock): EStreamStock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string stock_code */ 1:
                    message.stockCode = reader.string();
                    break;
                case /* double open */ 2:
                    message.open = reader.double();
                    break;
                case /* double high */ 3:
                    message.high = reader.double();
                    break;
                case /* double low */ 4:
                    message.low = reader.double();
                    break;
                case /* double close */ 5:
                    message.close = reader.double();
                    break;
                case /* double change */ 6:
                    message.change = reader.double();
                    break;
                case /* double changePercent */ 7:
                    message.changePercent = reader.double();
                    break;
                case /* double volume */ 8:
                    message.volume = reader.double();
                    break;
                case /* double value */ 9:
                    message.value = reader.double();
                    break;
                case /* double previousClose */ 10:
                    message.previousClose = reader.double();
                    break;
                case /* double avg */ 11:
                    message.avg = reader.double();
                    break;
                case /* int64 lastUpdated */ 12:
                    message.lastUpdated = reader.int64().toBigInt();
                    break;
                case /* double tradeVolume */ 13:
                    message.tradeVolume = reader.double();
                    break;
                case /* double araValue */ 14:
                    message.araValue = reader.double();
                    break;
                case /* double arbValue */ 15:
                    message.arbValue = reader.double();
                    break;
                case /* double bestBid */ 16:
                    message.bestBid = reader.double();
                    break;
                case /* double bestOffer */ 17:
                    message.bestOffer = reader.double();
                    break;
                case /* double totalFreq */ 18:
                    message.totalFreq = reader.double();
                    break;
                case /* market_trend.EForeign foreign */ 19:
                    message.foreign = EForeign.internalBinaryRead(reader, reader.uint32(), options, message.foreign);
                    break;
                case /* double error */ 20:
                    message.error = reader.double();
                    break;
                case /* string name */ 21:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EStreamStock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string stock_code = 1; */
        if (message.stockCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.stockCode);
        /* double open = 2; */
        if (message.open !== 0)
            writer.tag(2, WireType.Bit64).double(message.open);
        /* double high = 3; */
        if (message.high !== 0)
            writer.tag(3, WireType.Bit64).double(message.high);
        /* double low = 4; */
        if (message.low !== 0)
            writer.tag(4, WireType.Bit64).double(message.low);
        /* double close = 5; */
        if (message.close !== 0)
            writer.tag(5, WireType.Bit64).double(message.close);
        /* double change = 6; */
        if (message.change !== 0)
            writer.tag(6, WireType.Bit64).double(message.change);
        /* double changePercent = 7; */
        if (message.changePercent !== 0)
            writer.tag(7, WireType.Bit64).double(message.changePercent);
        /* double volume = 8; */
        if (message.volume !== 0)
            writer.tag(8, WireType.Bit64).double(message.volume);
        /* double value = 9; */
        if (message.value !== 0)
            writer.tag(9, WireType.Bit64).double(message.value);
        /* double previousClose = 10; */
        if (message.previousClose !== 0)
            writer.tag(10, WireType.Bit64).double(message.previousClose);
        /* double avg = 11; */
        if (message.avg !== 0)
            writer.tag(11, WireType.Bit64).double(message.avg);
        /* int64 lastUpdated = 12; */
        if (message.lastUpdated !== 0n)
            writer.tag(12, WireType.Varint).int64(message.lastUpdated);
        /* double tradeVolume = 13; */
        if (message.tradeVolume !== 0)
            writer.tag(13, WireType.Bit64).double(message.tradeVolume);
        /* double araValue = 14; */
        if (message.araValue !== 0)
            writer.tag(14, WireType.Bit64).double(message.araValue);
        /* double arbValue = 15; */
        if (message.arbValue !== 0)
            writer.tag(15, WireType.Bit64).double(message.arbValue);
        /* double bestBid = 16; */
        if (message.bestBid !== 0)
            writer.tag(16, WireType.Bit64).double(message.bestBid);
        /* double bestOffer = 17; */
        if (message.bestOffer !== 0)
            writer.tag(17, WireType.Bit64).double(message.bestOffer);
        /* double totalFreq = 18; */
        if (message.totalFreq !== 0)
            writer.tag(18, WireType.Bit64).double(message.totalFreq);
        /* market_trend.EForeign foreign = 19; */
        if (message.foreign)
            EForeign.internalBinaryWrite(message.foreign, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* double error = 20; */
        if (message.error !== 0)
            writer.tag(20, WireType.Bit64).double(message.error);
        /* string name = 21; */
        if (message.name !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message market_trend.EStreamStock
 */
export const EStreamStock = new EStreamStock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EForeign$Type extends MessageType<EForeign> {
    constructor() {
        super("market_trend.EForeign", [
            { no: 1, name: "buy", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "sell", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<EForeign>): EForeign {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.buy = 0;
        message.sell = 0;
        if (value !== undefined)
            reflectionMergePartial<EForeign>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EForeign): EForeign {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double buy */ 1:
                    message.buy = reader.double();
                    break;
                case /* double sell */ 2:
                    message.sell = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EForeign, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double buy = 1; */
        if (message.buy !== 0)
            writer.tag(1, WireType.Bit64).double(message.buy);
        /* double sell = 2; */
        if (message.sell !== 0)
            writer.tag(2, WireType.Bit64).double(message.sell);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message market_trend.EForeign
 */
export const EForeign = new EForeign$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TR0002$Type extends MessageType<TR0002> {
    constructor() {
        super("market_trend.TR0002", [
            { no: 1, name: "tradeDate", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "tradeTime", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "tradeNo", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "tradeType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "securityCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "boardCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "volume", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "buyerCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "buyerType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "sellerCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "sellerType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "bestBid", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 14, name: "bestBidVolume", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "bestOffer", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 16, name: "bestOfferVolume", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 17, name: "tradeTimestamp", kind: "message", T: () => Timestamp },
            { no: 18, name: "updatedDate", kind: "message", T: () => Timestamp },
            { no: 19, name: "timeStampStream", kind: "message", T: () => Timestamp },
            { no: 20, name: "fluctAmount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 21, name: "open", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 22, name: "high", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 23, name: "low", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 24, name: "freq", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 25, name: "totalVol", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 26, name: "totalAmount", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TR0002>): TR0002 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tradeDate = 0n;
        message.tradeTime = 0n;
        message.tradeNo = 0n;
        message.tradeType = "";
        message.securityCode = "";
        message.boardCode = "";
        message.price = 0;
        message.volume = 0n;
        message.buyerCode = "";
        message.buyerType = "";
        message.sellerCode = "";
        message.sellerType = "";
        message.bestBid = 0;
        message.bestBidVolume = 0n;
        message.bestOffer = 0;
        message.bestOfferVolume = 0n;
        message.fluctAmount = 0;
        message.open = 0;
        message.high = 0;
        message.low = 0;
        message.freq = 0;
        message.totalVol = 0;
        message.totalAmount = 0n;
        if (value !== undefined)
            reflectionMergePartial<TR0002>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TR0002): TR0002 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 tradeDate */ 1:
                    message.tradeDate = reader.int64().toBigInt();
                    break;
                case /* int64 tradeTime */ 2:
                    message.tradeTime = reader.int64().toBigInt();
                    break;
                case /* int64 tradeNo */ 3:
                    message.tradeNo = reader.int64().toBigInt();
                    break;
                case /* string tradeType */ 4:
                    message.tradeType = reader.string();
                    break;
                case /* string securityCode */ 5:
                    message.securityCode = reader.string();
                    break;
                case /* string boardCode */ 6:
                    message.boardCode = reader.string();
                    break;
                case /* double price */ 7:
                    message.price = reader.double();
                    break;
                case /* int64 volume */ 8:
                    message.volume = reader.int64().toBigInt();
                    break;
                case /* string buyerCode */ 9:
                    message.buyerCode = reader.string();
                    break;
                case /* string buyerType */ 10:
                    message.buyerType = reader.string();
                    break;
                case /* string sellerCode */ 11:
                    message.sellerCode = reader.string();
                    break;
                case /* string sellerType */ 12:
                    message.sellerType = reader.string();
                    break;
                case /* double bestBid */ 13:
                    message.bestBid = reader.double();
                    break;
                case /* int64 bestBidVolume */ 14:
                    message.bestBidVolume = reader.int64().toBigInt();
                    break;
                case /* double bestOffer */ 15:
                    message.bestOffer = reader.double();
                    break;
                case /* int64 bestOfferVolume */ 16:
                    message.bestOfferVolume = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp tradeTimestamp */ 17:
                    message.tradeTimestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.tradeTimestamp);
                    break;
                case /* google.protobuf.Timestamp updatedDate */ 18:
                    message.updatedDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedDate);
                    break;
                case /* google.protobuf.Timestamp timeStampStream */ 19:
                    message.timeStampStream = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timeStampStream);
                    break;
                case /* double fluctAmount */ 20:
                    message.fluctAmount = reader.double();
                    break;
                case /* double open */ 21:
                    message.open = reader.double();
                    break;
                case /* double high */ 22:
                    message.high = reader.double();
                    break;
                case /* double low */ 23:
                    message.low = reader.double();
                    break;
                case /* int32 freq */ 24:
                    message.freq = reader.int32();
                    break;
                case /* int32 totalVol */ 25:
                    message.totalVol = reader.int32();
                    break;
                case /* int64 totalAmount */ 26:
                    message.totalAmount = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TR0002, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 tradeDate = 1; */
        if (message.tradeDate !== 0n)
            writer.tag(1, WireType.Varint).int64(message.tradeDate);
        /* int64 tradeTime = 2; */
        if (message.tradeTime !== 0n)
            writer.tag(2, WireType.Varint).int64(message.tradeTime);
        /* int64 tradeNo = 3; */
        if (message.tradeNo !== 0n)
            writer.tag(3, WireType.Varint).int64(message.tradeNo);
        /* string tradeType = 4; */
        if (message.tradeType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tradeType);
        /* string securityCode = 5; */
        if (message.securityCode !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.securityCode);
        /* string boardCode = 6; */
        if (message.boardCode !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.boardCode);
        /* double price = 7; */
        if (message.price !== 0)
            writer.tag(7, WireType.Bit64).double(message.price);
        /* int64 volume = 8; */
        if (message.volume !== 0n)
            writer.tag(8, WireType.Varint).int64(message.volume);
        /* string buyerCode = 9; */
        if (message.buyerCode !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.buyerCode);
        /* string buyerType = 10; */
        if (message.buyerType !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.buyerType);
        /* string sellerCode = 11; */
        if (message.sellerCode !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.sellerCode);
        /* string sellerType = 12; */
        if (message.sellerType !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.sellerType);
        /* double bestBid = 13; */
        if (message.bestBid !== 0)
            writer.tag(13, WireType.Bit64).double(message.bestBid);
        /* int64 bestBidVolume = 14; */
        if (message.bestBidVolume !== 0n)
            writer.tag(14, WireType.Varint).int64(message.bestBidVolume);
        /* double bestOffer = 15; */
        if (message.bestOffer !== 0)
            writer.tag(15, WireType.Bit64).double(message.bestOffer);
        /* int64 bestOfferVolume = 16; */
        if (message.bestOfferVolume !== 0n)
            writer.tag(16, WireType.Varint).int64(message.bestOfferVolume);
        /* google.protobuf.Timestamp tradeTimestamp = 17; */
        if (message.tradeTimestamp)
            Timestamp.internalBinaryWrite(message.tradeTimestamp, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updatedDate = 18; */
        if (message.updatedDate)
            Timestamp.internalBinaryWrite(message.updatedDate, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp timeStampStream = 19; */
        if (message.timeStampStream)
            Timestamp.internalBinaryWrite(message.timeStampStream, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* double fluctAmount = 20; */
        if (message.fluctAmount !== 0)
            writer.tag(20, WireType.Bit64).double(message.fluctAmount);
        /* double open = 21; */
        if (message.open !== 0)
            writer.tag(21, WireType.Bit64).double(message.open);
        /* double high = 22; */
        if (message.high !== 0)
            writer.tag(22, WireType.Bit64).double(message.high);
        /* double low = 23; */
        if (message.low !== 0)
            writer.tag(23, WireType.Bit64).double(message.low);
        /* int32 freq = 24; */
        if (message.freq !== 0)
            writer.tag(24, WireType.Varint).int32(message.freq);
        /* int32 totalVol = 25; */
        if (message.totalVol !== 0)
            writer.tag(25, WireType.Varint).int32(message.totalVol);
        /* int64 totalAmount = 26; */
        if (message.totalAmount !== 0n)
            writer.tag(26, WireType.Varint).int64(message.totalAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message market_trend.TR0002
 */
export const TR0002 = new TR0002$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EStockInfo$Type extends MessageType<EStockInfo> {
    constructor() {
        super("market_trend.EStockInfo", [
            { no: 1, name: "percentChange", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "notation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "change", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "totalFreq", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "totalVolume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "lastUpdated", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EStockInfo>): EStockInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.percentChange = 0;
        message.code = "";
        message.notation = "";
        message.price = 0;
        message.change = 0;
        message.totalFreq = 0;
        message.totalVolume = 0;
        message.volume = 0;
        message.value = 0;
        message.name = "";
        message.lastUpdated = 0n;
        if (value !== undefined)
            reflectionMergePartial<EStockInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EStockInfo): EStockInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double percentChange */ 1:
                    message.percentChange = reader.double();
                    break;
                case /* string code */ 2:
                    message.code = reader.string();
                    break;
                case /* string notation */ 3:
                    message.notation = reader.string();
                    break;
                case /* double price */ 4:
                    message.price = reader.double();
                    break;
                case /* double change */ 5:
                    message.change = reader.double();
                    break;
                case /* double totalFreq */ 6:
                    message.totalFreq = reader.double();
                    break;
                case /* double totalVolume */ 7:
                    message.totalVolume = reader.double();
                    break;
                case /* double volume */ 8:
                    message.volume = reader.double();
                    break;
                case /* double value */ 9:
                    message.value = reader.double();
                    break;
                case /* string name */ 10:
                    message.name = reader.string();
                    break;
                case /* int64 lastUpdated */ 11:
                    message.lastUpdated = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EStockInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double percentChange = 1; */
        if (message.percentChange !== 0)
            writer.tag(1, WireType.Bit64).double(message.percentChange);
        /* string code = 2; */
        if (message.code !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.code);
        /* string notation = 3; */
        if (message.notation !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.notation);
        /* double price = 4; */
        if (message.price !== 0)
            writer.tag(4, WireType.Bit64).double(message.price);
        /* double change = 5; */
        if (message.change !== 0)
            writer.tag(5, WireType.Bit64).double(message.change);
        /* double totalFreq = 6; */
        if (message.totalFreq !== 0)
            writer.tag(6, WireType.Bit64).double(message.totalFreq);
        /* double totalVolume = 7; */
        if (message.totalVolume !== 0)
            writer.tag(7, WireType.Bit64).double(message.totalVolume);
        /* double volume = 8; */
        if (message.volume !== 0)
            writer.tag(8, WireType.Bit64).double(message.volume);
        /* double value = 9; */
        if (message.value !== 0)
            writer.tag(9, WireType.Bit64).double(message.value);
        /* string name = 10; */
        if (message.name !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.name);
        /* int64 lastUpdated = 11; */
        if (message.lastUpdated !== 0n)
            writer.tag(11, WireType.Varint).int64(message.lastUpdated);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message market_trend.EStockInfo
 */
export const EStockInfo = new EStockInfo$Type();
/**
 * @generated ServiceType for protobuf service market_trend.DataStream
 */
export const DataStream = new ServiceType("market_trend.DataStream", [
    { name: "StreamData", serverStreaming: true, options: {}, I: FilterRequest, O: DataStreamResponse }
]);
